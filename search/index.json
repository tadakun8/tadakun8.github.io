[{"content":"Level 4 Goal  The password for the next level is stored in a hidden file in the inhere directory.\n  inhereディレクトリの隠しファイルからパスワードを取得する  resolve bandit3@bandit:~$ cd inhere/ bandit3@bandit:~/inhere$ ls -a . .. .hidden bandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB bandit3@bandit:~/inhere$ exit # ここからローカル $ ssh -l bandit4 -p 2220 bandit.labs.overthewire.org This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit4@bandit.labs.overthewire.org's password: pIwrPrtPN36QITSp3EQaw936yaFoFgAB resolveまでにやったこと 特になし\nLevel 5  The password for the next level is stored in the only human-readable file in the inhere directory. Tip: if your terminal is messed up, try the “reset” command.\n  inhereディレクトリにある人間に読むことのできるファイルからパスワードを取得する  Goal resolve bandit4@bandit:~$ cd inhere/ bandit4@bandit:~/inhere$ ls -file00 -file01 -file02 -file03 -file04 -file05 -file06 -file07 -file08 -file09 bandit4@bandit:~/inhere$ ls | xargs -I {} awk 1 ./{} �/`2ғ�%��rL~5�g��� ����� ��p,k�;��r*�� �.!��C��J �dx,� e�)�#��5�� ��p��V�_���ׯ�mm ������h!TQO�`�4\u0026quot;aל�߂phT��,�A ?�4�ו$����I\u0026amp;������c���ގ.� �r�l$�?h�9('���!y�e�#�x�O��=�� ly���~��A�f����-E�{���m�����ܗM koReBOKuIDDepwhWk7jZC0RTdopnAYKh # これが目的のパスワード �T�?�i��j��îP�F�l�n��J����{��@ �e�0$�in=��_b�5FA�P7sz��gNT bandit4@bandit:~/inhere$ exit # ここからローカル $ ssh -l bandit5 -p 2220 bandit.labs.overthewire.org ?[master] This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit5@bandit.labs.overthewire.org's password: koReBOKuIDDepwhWk7jZC0RTdopnAYKh resolveまでにやったこと 特につまりはしませんでしたが、lsするとファイルが何個もありました。これを全てcatしてもよかったのですが、せっかくならもう少しうまいやり方でできないか調べてみました。\n最初はls | xargs -I{} cat ./{}でやったのですが・・・\nbandit4@bandit:~/inhere$ ls | xargs -I{} cat ./{} �/`2ғ�%��rL~5�g��� �������p,k�;��r*�� �.!��C��J �dx,�e�)�#��5�� ��p��V�_���ׯ�mm������h!TQO�`�4\u0026quot;aל�߂phT��,�Ai�4�ו$����I\u0026amp;��?��r�l$�?h�9('���!y�e�#�x�O��=��ly���~��A�f����-E�{���m�����ܗMkoReBOKuIDDepwhWk7jZC0RTdopnAYKh �T�?�i��j��îP�F�l�n��J����{��@�e�0$�in=��_b�5FA�P7sz��gNbandit4@bandit:~/inhere$ 読みづらい・・・\ncatに2つ以上のファイルを引数に取る場合、ファイルに改行が入ってなかったらそのまま表示されるらしいです。ファイルごとに改行して欲しかったので、なにかないかと模索したところ以下のサイトにたどり着きました\n 複数のファイルを終端に改行がなければ改行を追加して結合する  awk 1でいけるっぽいです。この記事で出てくるawkのパターンとかアクションとかがわからなかったので、それは以下の記事で補完しました\n awk パターンとアクション  awkコマンド（テキストの加工やパターン処理をする）   awkについてわかったことは\n 文法はawk 'pattern {action} ファイル名' actionではファイルの各行に適用させる動作  actionは省略でき、省略した場合はその行を標準出力するアクションになる   patternはactionを適用させる行の条件(正規表現とかで指定するみたい)  ここで1を指定すると全ての行にactionを適用させるということになる    Level 6 Goal  The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties: human-readable, 1033 bytes in size, not executable\n  パスワードはinhereディレクトリに格納されている そのファイルは以下の特徴を持っている  人間に読める 1033bytes 実行できない    resolve bandit5@bandit:~/inhere$ find -type f -size 1033c -print0 ! -executable |　xargs -0 -I{} cat ./{} DXjZPULLxYr17uwoI01bNLQbtFemEgo7 resolveまでにやったこと まずはfindのオプションを調べました。特に実行権限を持っていないファイルの検索の仕方ですね。調べると検索オプションの前に!をつけて否定系にすればよかったようです。\nまた、調べているうちに、findに-print0とつけてxargs -0 ・・・としているいるものも散見されました。\nxargs -0の正体 xargsの -0は区切り文字をヌル文字(\\0)にするオプションです。デフォルトは空白や改行コードです。\n-0をつけないと何が困るのか xargsで処理する引数に空白がある場合に困っちゃう\n例えば以下のケース\n$ ls space in the finename.txt # こいつを消したい $ find . -name '*.txt' | xargs rm rm: ./space: No such file or directory rm: in: No such file or directory rm: the: No such file or directory rm: filename.txt: No such file or directory 何も指定しないと、空白ごとにrmしてしまいます。意図した動作にするために区切り文字を変えるために-0をつけて対応します。\nfind -print0の理由 xargs -0としたので、xargsの処理ではヌル文字が区切り文字になりました。findで-print0をつけることで結果のファイル名の末尾にヌル文字が付与されます。これでxargsの処理が意図する動作になります。\n参考サイト  findコマンドでの検索時に、否定の条件を指定する findとxargsコマンドで-print0オプションを使う理由(改) 0212【Linux】xargs コマンドの使い方がよく分からない  今日はおしまい find便利ですね。find . -name 'hogehoge'という定型で覚えて使ってましたが、オプションやxargsと組み合わせれば全文検索なんかもできそうです。副次的に色々なtipsも知ることができるので、モチベーションを保てています。\n","date":"2021-06-15T19:47:28+09:00","permalink":"https://tadakun8.github.io/post/over-the-wire/bandit/level4-6/","title":"【OverTheWrite奮闘記】Bandit: Level4〜6"},{"content":"はじめに 僕もエンジニアの端くれではあるので、たまにQiitaで面白い記事を読んでます。いつも通りQiitaを見ているとこんな記事がありました\n イスラエル8200部隊出身のガチプロハッカーに、一流のハッカーになる方法について聞いてみた。  こういう記事を見るとなんだかワクワクします。\nこの記事の中で以下が気になり、\n ハッキングチャレンジはその名の通り、ハッキングを試してみることです。有名なのは『OverTheWire』でしょうか。\n 少し調べてみると・・・ふむふむ、ゲーム形式でハッキングを練習し、セキュリティの知識を身につけることができるサイトのようだとわかりました。\nガチプロハッカーになるつもりはありませんが、こういった知識も身につけたいなと思ってはいたので、これを機会にこのOverTheWriteで練習してみることにしました。\n私の今の状態  セキュリティの知識はカッスカス 大学時代にセキュリティの講義受けたなぁ(遠い目)  Level 0 初心者はまずBandit(意味は盗賊)からスタートです\nGoal  The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is bandit0 and the password is bandit0. Once logged in, go to the Level 1 page to find out how to beat Level 1.\n level0のゴールを整理すると\n sshで指定ホストにログインすること  ホストはbandit.labs.overthewire.org ポートは2220 ユーザーネームはbandit0 パスワードもbandit0    sshコマンド使うんだなとアタリがつきました\nresolve $ ssh -l bandit0 -p 2220 bandit.labs.overthewire.org This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit0@bandit.labs.overthewire.org's password: bandit0 resolveまでにやったこと sshコマンドか、それならやったことある！と思って以下のコマンドでエラー\n$ ssh bandit0@bandit.labs.overthewire.org:2220 ちゃんと$ man sshでしっかりドキュメントをみることが教訓になりました\nLevel 1 Goal  The password for the next level is stored in a file called readme located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game.\n  sshでbandit1ユーザとしてログインする passwordはhomeディレクトリのreadmeファイルの中に書いてある  resolve $ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 $ exit $ ssh -l bandit1 -p 2220 bandit.labs.overthewire.org This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit0@bandit.labs.overthewire.org\u0026#39;s password: boJ9jbbUNNfktd78OOpsqOltutMc3MY1 resolveまでにやったこと 基本的なlinuxコマンドだったので特にやったことはありませんでした\nLevel 2 Goal  The password for the next level is stored in a file called - located in the home directory\n  -というファイルの中のパスワードを入手する  resolve $ cat ./- CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 resolveまでにやったこと -という名前のフォルダをどうやってcatするのかがわからなかったので詰まりました\nハイフンをエスケープすればいいのかなと思って$ cat \\-を試しましたがうまくいかず。 $ man catでオプションを調べてみましたが、ピンとくるものはなかったです。\ncat ファイル名 ハイフンで検索してみて以下のサイトにたどり着きました\n 【linux】ハイフンから始まるファイル名を指定できない（エラーになる）  どうやら、ハイフンで始まるファイル名をそのままcatするとうまくいかないみたいです。パスで指定してあげればハイフンから始まるファイルでもcatできそうだとわかりました\nここまで調べて回答がわかったのですが、そもそも問題文の下に\n Google Search for “dashed filename”\n と書いてました・・・\nLevel 3 Goal  The password for the next level is stored in a file called spaces in this filename located in the home directory\n  ファイル名がスペース(空白)であるファイルからパスワードを入手する spaces in filenameというファイルからパスワードを入手する  resolve $ cat spaces\\ in\\ this\\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK $ exit $ ssh -l bandit3 -p 2220 bandit.labs.overthewire.org This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit3@bandit.labs.overthewire.org's password: UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK resolveまでにやったこと ls -lしても空白で始まるファイルがないなぁと思ってましたが、どうやら勘違いをしていたようです。\nLevel2では\n The password for the next level is stored in a file called - located in the home directory\n こういうゴールで、パスワードは使わないのかと思ってましたが、そんな訳ない\nちゃんとThe password for the next levelと書いてあるので、Level2で取得したパスワードと次のユーザであるbandit2で改めてsshをログインしてからLevel 3に進むみたいです。\n省略せんといて・・・\nなので改めて\n$ ssh -l bandit2 -p 2220 bandit.labs.overthewire.org This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit2@bandit.labs.overthewire.org's password: CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 bandit2でログインし直してからLevel 3に行きました\n今日はおしまい いろいろトラブルはあったものの、Level 3までできました。1つ気をつけたいのが、sshしてコマンドを打たない時が一定時間を超えると入力を受け付けなくなります。おそらくsshのタイムアウトでしょうか？その時はもう一度ログインし直せばOKです。\n","date":"2021-06-13T21:52:17+09:00","permalink":"https://tadakun8.github.io/post/over-the-wire/bandit/level0-3/","title":"【OverTheWrite奮闘記】Bandit: Leve0〜3"},{"content":"はじめに 同僚には凄腕のshell職人がいます。案件で、APIのクライアントにPostmanが推奨されているのですが、そのshell職人がcurlを使ってるのを隣で見てました。覚えたら手軽そうだなと思ったのでこれを機にcurlの使い方を覚えたいとのモチベがありました。\n使い方 $ curl [OPTION] URL 使い方だけ見れば簡単ですが、curlに関わらずlinuxコマンドはオプションをどれだけ頭にインデックスするかだと思います。\nユースケースでオプション紹介 POSTしたい $ curl -X POST -d id=1 -d email=sample@example.com URL  -X : HTTPメソッドを指定できる -d : リクエストボディを指定できる  1つ1つ指定する =(イコール)で定義していく    ヘッダー情報を追加してリクエストしたい $ curl -H \u0026#39;Content-Type: application/json\u0026#39; URL # または $ curl --header \u0026#39;Content-Type: application/json\u0026#39; URL レスポンスヘッダ「だけ」表示したい $ curl -I URL # または $ curl --head URL レスポンスヘッダ「も」表示したい $ curl -i URL # または $ curl --include URL 詳細な情報も表示したい $ curl -v URL $ curl --verbose URL 余計な情報は表示したくない $ curl -s URL $ curl --silent URL curlは以下のような進捗状況を表示してくれますが、-sでこの表示を抑制します\n % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 112 100 112 0 0 424 0 --:--:-- --:--:-- --:--:-- 424 このあとは・・・？ 使わないと覚えないので、試しにコマンドを叩いてみることをお勧めします。Public APIと検索すれば無料で使えるAPIが表示されるので、そこの中から選んでcurlしてみましょう！QiitaにもPublic APIをまとめている記事があったので、参考に載せておきます。私はこの中の、https://icanhazdadjoke.com/ (親父ギャグを返してくれるAPI)を使って試しました。\n参考  【随時更新】一風変わったWeb APIをまとめてみた  ","date":"2021-06-13T15:32:18+09:00","permalink":"https://tadakun8.github.io/post/usage-curl/","title":"curlコマンドの使い方"},{"content":"インストール方法 $ npm install axios GET, POST, PUT, DELETEリクエスト const responseGet = await axios.get(\u0026#39;http://example.com/api/sample\u0026#39;) const responsePost = await axios.post(\u0026#39;http://example.com/api/sample\u0026#39;, { id: 1 }) const responsePut = await axios.put(\u0026#39;http://example.com/api/sample\u0026#39;, { id: 1 }) const responseDelete = await axios.delete(\u0026#39;http://example.com/api/sample\u0026#39;, { id: 1 }) axiosでの共通設定をしたいとき // axiosを使う時の共通設定 const config: AxiosRequestConfig = { // axiosClient.get(\u0026#39;sample\u0026#39;)でhttp://example.com/api/sampleへのリクエストになるように設定  baseURL: \u0026#39;http://example.com/api/\u0026#39;, // タイムアウト(ミリ秒)  timeout: 1000, // カスタムヘッダーも定義できる  headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;sample-token\u0026#39;, } } // 共通設定をしたaxiosインスタンスの生成 const axiosClient: AxiosInstance = axios.create(config) 共通設定できる値は上記以外にもまだまだあるので、詳しくはaxiosの公式HPに記載されてます\n※ 以降はaxiosClientを使う前提です\n共通設定で指定している値をこのAPIでは適用したくない場合 \u0008axiosClient.get(\u0026#39;sample\u0026#39;, { timeout: 2000 }) ユースケースとしては、以下が当てはまりそうです\n あるAPIのリクエストではタイムアウトの値を伸ばしたい あるAPIだけ、カスタムヘッダーを定義したい  クエリパラメータ付きリクエスト // http://eample.com/api/sample?id=3となる const responseQueryParam = await axiosClient.get(\u0026#39;sample\u0026#39;, { params: { id: 3 } }) 画像をアップロード const formData = new FormData() formData.append(\u0026#39;fineName\u0026#39;, 実際のファイルオブジェクト) const responseFormData = await axiosClient.post(\u0026#39;sample\u0026#39;, formData, { headers: { \u0026#39;content-type\u0026#39;: \u0026#39;multipart/form-data\u0026#39; } }) エラーハンドリング const responseError = await axiosClient.get(\u0026#39;sample\u0026#39;) .catch(err =\u0026gt; { return err.response } ) if(responseError.status != 200) { console.log(\u0026#39;例外処理を記載する\u0026#39;) } モックのレスポンスを返したい const mockResponseData = { id: 3, title: \u0026#39;平成狸合戦ぽんぽこ\u0026#39; } const mockAdapter = (config) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { resolve({　data: mockResponseData, status: 200 }) }) } const responseMock = await axiosClient.get(\u0026#39;url\u0026#39;, { adapter: mockAdapter }) (バックエンドが実装されていないが、フロントエンドの動作確認をしたいときに使えそう)\n処理を差し込みたい 以下は、最終的にどういうリクエストを送ったのか、どういうレスポンスが返ってきたのかをログを出力するような差し込み処理です\naxiosClient.interceptors.request.use((config) =\u0026gt; { console.log(JSON.stringify(config)) return config }) axiosClient.interceptors.response.use(response =\u0026gt; { console.log(JSON.stringify(response)) return response }) axios.interceptors.request.use((config) =\u0026gt; { console.log(\u0026#39;interceptのuseはrequest、responseで複数書ける\u0026#39;) console.log(\u0026#39;実行される順番は最初に定義したものからinterceptされる\u0026#39;) console.log(\u0026#39;目的ごとにuseを分けた方がよいだろう\u0026#39;) return config }) おわりに 先人たちがまとめてくださった記事をもとに、\u0008\u0008axiosを使うときに困らないだろう程度にはまとめることができました。\ndebugのたびにconsole.log(JSON.stringfy(response))などで値を見てましたが、interceptorsにログ出力を設定してあるaxiosインスタンスを使えば、その必要がなくなりそうです。\n参考  axios 知見集(2017) axios [フロントエンド] axiosライブラリを使って、柔軟にHTTP通信を行う 【JavaScript】axiosのエラーを共通の処理で拾う 【JavaScript】axiosのエラーを共通の処理で拾う axiosの使い方まとめ (GET/POST/例外処理) axios で添付ファイルありのリクエスト(multipart/form-data の POST) 【React】axiosを使用してmultipart/form-data形式の通信をする  ","date":"2021-06-13T10:04:20+09:00","permalink":"https://tadakun8.github.io/post/usage-axios/","title":"axiosの使い方"},{"content":"はじめに 開発が進んでいくと、コミットメッセージを変更したいなぁということがあると思います。また、「このコミットメッセージわかりにくい」と言われることもあるでしょう。特に、2つ以上前のコミットメッセージを変える方法はいつも調べているので、記事にしました。\n直近のコミットメッセージを変更する場合 git commit --amendで修正できます\n想定するケース [~/workspace/sample] ❯❯❯ git log --oneline --no-decorate c7c87bd commit 4 ← 番号がずれてしまった 8b72c5c commit 2 13ba7d2 commit 1 直近のコミットメッセージの番号がずれていますので、commit 4 を commit 3に修正しましょう\n修正 直近のコミットメッセージを変更する場合は以下のコマンドですぐ変更できます\n$ git commit --amend そうするとvimが起動するので、commit 4 を commit 3に変更しましょう。\n変更後に確認すると、意図した結果になってます\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate af9e74a commit 3 8b72c5c commit 2 13ba7d2 commit 1 2つ以上前のコミットメッセージを変更する場合 いよいよ本題です。こちらはgit rebaseを使って修正します。\n想定するケース コミットの履歴を以下だとしましょう\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate 0638aca commit 5 cb1a280 commit 4 2572e35 commit 3 b1ce602 commit 22 13ba7d2 commit 1 commit 2 のつもりが commit 22 となっています\n修正 # commit 1のコミットIDを引数にし、commit 22までをrebaseの範囲とする $ git reabase -i 13ba7d2 vimが立ち上がるので、commit 22の pick を r(またはreword) に変更します\n- pick b1ce602 commit 22 + r b1ce602 commit 22 pick 2572e35 commit 3 pick cb1a280 commit 4 pick 0638aca commit 5 # Rebase 13ba7d2..0638aca onto 0638aca (4 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with \u0026#39;git rebase --continue\u0026#39;) # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label 確認すると意図した結果になっていますね\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate 9f6ecb5 commit 5 bbf2396 commit 4 4d7d435 commit 3 f5312fb commit 2 13ba7d2 commit 1 このあとは・・・？ pushしてリモートリポジトリを随時更新してください。コミットの履歴を変えたので、git push -fでないとpushできないので、お気をつけて。\n","date":"2021-06-13T09:16:53+09:00","image":"https://tadakun8.github.io/post/git-change-commit-message/git_hu10f4824aa557e0c7b4f2ec1dc4ef34d0_28593_120x120_fill_box_smart1_2.png","permalink":"https://tadakun8.github.io/post/git-change-commit-message/","title":"コミットメッセージを変更する"},{"content":"はじめに コミットのまとめ方を毎回調べているのでメモ\n直前のコミットをまとめる場合 現在のコミットが以下だと仮定します\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate 7a0470f commit 5 ce15d24 commit 4 346c3f2 commit 3 894afa7 commit 2 31bea46 commit 1  --oneline : 各コミットを1行で表示する --no-decorate : 余計な装飾を消す 1  以下の状態になるようにコミットをまとめてみましょう\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate d8feda4 commit 5、4、3をまとめました 894afa7 commit 2 31bea46 commit 1 手順 $ git rebase -i HEAD~3 # 直前の3つコミットをrebase 何も設定していなければvimが起動し、以下が表示されます\n[~/workspace/sample] ❯❯❯ git rebase -i HEAD~3 [master] hint: Waiting for your editor to close the file... pick 346c3f2 commit 3 pick ce15d24 commit 4 pick 7a0470f commit 5 # Rebase 894afa7..7a0470f onto 894afa7 (3 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026quot;squash\u0026quot;, but discard this commit's log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label # m, merge [-C \u0026lt;commit\u0026gt; | -c \u0026lt;commit\u0026gt;] \u0026lt;label\u0026gt; [# \u0026lt;oneline\u0026gt;] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c \u0026lt;commit\u0026gt; to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 次に、まとめたいコミットを pick から s(またはsquash) に変更します。イメージ的にはcommit 4とcommit 5をcommit 3にまとめるようなイメージです\npick 346c3f2 commit 3 - pick ce15d24 commit 4 - pick 7a0470f commit 5  pick 346c3f2 commit 3 + s ce15d24 commit 4 + s 7a0470f commit 5 保存すると、まとめたコミットのコミットメッセージを入力する画面が表示されます\n# This is a combination of 3 commits. # This is the 1st commit message: commit 3 # This is the commit message #2: commit 4 # This is the commit message #3: commit 5 #がついていないものがコミットメッセージとして適用されます。なので今回はこれらを消して以下のメッセージに修正します\ncommit 5、4、3をまとめました これで保存すると想定通りコミットがまとまりました\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate d8feda4 commit 5、4、3をまとめました 894afa7 commit 2 31bea46 commit 1 離れたコミットをまとめる場合 現在のコミットが以下だと仮定します\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate 7a0470f commit 5 ce15d24 commit 4 346c3f2 commit 3 894afa7 commit 2 31bea46 commit 1 以下の状態になるようにコミットをまとめてみましょう\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate 7a0470f commit 5 ce15d24 commit 4 bc9ff20 commit 2, 3をまとめました 894afa7 commit 1 手順 手順としては先ほどと同様です。イメージとしてはcommit3をコミット2にまとめるようなイメージを持ってください。なので、commit3のpickをs(squash)に変更してあげましょう。\n$ git rebase -i 894afa7 # 引数にコミットIDを指定するとその次のコミット(ここではcommit2)までがrebaseの範囲になる 表示されるvim画面は以下になります\npick 894afa7 commit 2 pick 346c3f2 commit 3 pick ce15d24 commit 4 pick 7a0470f commit 5 # Rebase 31bea46..7a0470f onto 7a0470f (4 commands) # # Commands: # p, pick \u0026lt;commit\u0026gt; = use commit # r, reword \u0026lt;commit\u0026gt; = use commit, but edit the commit message # e, edit \u0026lt;commit\u0026gt; = use commit, but stop for amending # s, squash \u0026lt;commit\u0026gt; = use commit, but meld into previous commit # f, fixup \u0026lt;commit\u0026gt; = like \u0026quot;squash\u0026quot;, but discard this commit's log message # x, exec \u0026lt;command\u0026gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop \u0026lt;commit\u0026gt; = remove commit # l, label \u0026lt;label\u0026gt; = label current HEAD with a name # t, reset \u0026lt;label\u0026gt; = reset HEAD to a label # m, merge [-C \u0026lt;commit\u0026gt; | -c \u0026lt;commit\u0026gt;] \u0026lt;label\u0026gt; [# \u0026lt;oneline\u0026gt;] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c \u0026lt;commit\u0026gt; to reword the commit message. # いつものようにまとめたいコミットの pick を s(またはsquash) に変更しましょう\npick 894afa7 commit 2 - pick 346c3f2 commit 3 pick ce15d24 commit 4 pick 7a0470f commit 5 pick 894afa7 commit 2 + s 346c3f2 commit 3 pick ce15d24 commit 4 pick 7a0470f commit 5 保存して、コミットメッセージをcommit 2, 3をまとめましたと書けば想定した結果になるはずです\n[~/workspace/sample] ❯❯❯ git log --oneline --no-decorate f5cade0 commit 5 04ac645 commit 4 bc9ff20 commit 2, 3をまとめました 31bea46 commit 1 このあとは・・・？ 変更が終わったら、リモートリポジトリにpushしましょう。\nただ、rebaseした後にリモートリポジトリにpushしようとするとエラーがでます。ローカルとリモートの履歴が異なるので当たり前ですね。その場合はgit push -f origin ブランチ名でpushできます。\n ただし、git push -f はリモートリポジトリに現在のブランチの状態を強制的にpushします。リモートリポジトリの状態を強制的に変更するコマンドなので、必ず今の変更があっているかを確かめてから使うようにしてください。  参考  rebase -i でコミットをまとめる   git rebase -iでgitのコミットをまとめる    このオプションをつけないと最新のcommitが7a0470f (HEAD -\u0026gt; master) commit 5と表示されます。ここでは表示をわかりやすくするために、このオプションをつけました\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-06-12T20:58:32+09:00","image":"https://tadakun8.github.io/post/git-put-together-commits/git_hu10f4824aa557e0c7b4f2ec1dc4ef34d0_28593_120x120_fill_box_smart1_2.png","permalink":"https://tadakun8.github.io/post/git-put-together-commits/","title":"commitをまとめる"},{"content":"はじめに ここでは、Swaggerで定義したAPIからモックサーバを立てる方法を書いていきます。SwaggerのDockerイメージを利用してモックサーバを構築する方法もありますが、ここではSwagger Editorを使用する方法について書きます。\n手順 モックサーバファイルをダウンロード モックサーバをローカルで立ち上げるために必要なファイルをダウンロードします\n  まずはswagger editorにアクセスしてください\n  上部のGenerate Serverをクリックしてどの言語でモックサーバを立てるかを選んでください\n この記事ではnodejs-serverを選択した想定で進みます    選択するとzipファイルがダウンロードされるので、任意のフォルダで展開してください\n  swagger.yamlを修正 ローカルでAPIを叩けるようにするために、api/swagger.yamlを変更する必要があります。 具体的にはappフォルダにあるswagger.yamlのhostとschemasの値を変更します。\n- host: \u0026#34;petstore.swagger.io\u0026#34; + host: \u0026#34;localhost:8080\u0026#34;  schemes: - \u0026#34;https\u0026#34; ← これを消す - \u0026#34;http\u0026#34; 必要なモジュールのインストール $ npm install  展開したディレクトリのpackage.jsonがあるディレクトリ内でこのコマンドを叩いてください  モックサーバを立ち上げる 同じディレクトリで以下のコマンドを叩いてサーバを立ち上げます\n$ npm run start http://localhost:8080/docs/にアクセスすると、Swagger UIが立ち上がるはずです。Swagger UIで試してみても良いですし、ブラウザの検索窓からhttp://localhost:8080/v2/pet/3と叩けばjsonのレスポンスが返ってくることを確認できるはずです\nこのあとは・・・？ この手順で使用したAPIはSwagger Editor用意したサンプルのAPIになります。swagger.yamlを修正し、プロジェクトに必要なAPIを定義していけばよいでしょう。\nまた、フロントエンドの確認をしたい場合はリクエスト先をhttp://localhost:8080/v2/pet/3のようにしてあげれば、バックエンドが実装されていなくても、フロントエンドの確認をすることができますね！\nSwagger本来の用途であるAPI仕様書としても使用できるので、このフォルダをgit管理してプロジェクトで共有するということをおすすめします。\n参考  外部連携APIのモックサーバをSwaggerを利用して作る  ","date":"2021-06-10T21:15:14+09:00","image":"https://tadakun8.github.io/post/creating-a-mock-server-with-swagger/swagger_hud0891c2854f0c20622944d709dd43a21_23653_120x120_fill_q75_box_smart1.jpg","permalink":"https://tadakun8.github.io/post/creating-a-mock-server-with-swagger/","title":"Swaggerでモックサーバを立てる"},{"content":"Conclusion jsconfig.jsonとはvscodeでjavascriptを書くときに便利にコーディングできるようにする設定ファイルのことです\nexample 以下は、create-nuxt-appコマンドで作成されたjsconfig.jsonの例\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;~/*\u0026#34;: [\u0026#34;./*\u0026#34;], \u0026#34;@/*\u0026#34;: [\u0026#34;./*\u0026#34;], \u0026#34;~~/*\u0026#34;: [\u0026#34;./*\u0026#34;], \u0026#34;@@/*\u0026#34;: [\u0026#34;./*\u0026#34;] } }, \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;.nuxt\u0026#34;, \u0026#34;dist\u0026#34;] } Remarks  typescriptの場合はtsconfig.jsonになる  Reference  jsconfig.json(公式ページ) 【TypeScript】TSConfigの基礎 tsconfig.jsonのrootDirとbaseUrlに関するメモ [TypeScript] tsconfig.jsonの全オプションを理解する（随時追加中）  ","date":"2021-06-10T19:59:50+09:00","permalink":"https://tadakun8.github.io/post/what-is-jsconfig-json/","title":"jsconfig.jsonとは？"},{"content":"はじまりはじまり\n","date":"2021-06-08T23:41:15+09:00","permalink":"https://tadakun8.github.io/post/start-blog/","title":"ブログはじめました"}]